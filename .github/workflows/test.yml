name: Test TCP and UDP Tunnels

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read

jobs:
  test-tunnels:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Install dependencies
        run: |
          # Install socat for tunnel operations
          sudo apt-get update
          sudo apt-get install -y socat openssh-server netcat-openbsd
      
      - name: Setup SSH server
        run: |
          # Generate SSH host keys
          sudo ssh-keygen -A
          
          # Generate SSH key pair for testing
          mkdir -p ~/.ssh
          ssh-keygen -t ed25519 -f ~/.ssh/test_key -N ""
          cat ~/.ssh/test_key.pub >> ~/.ssh/authorized_keys
          chmod 600 ~/.ssh/authorized_keys
          chmod 700 ~/.ssh
          
          # Configure SSH server
          sudo tee /etc/ssh/sshd_config.d/test.conf > /dev/null <<EOF
          Port 2222
          PermitRootLogin no
          PubkeyAuthentication yes
          PasswordAuthentication no
          GatewayPorts yes
          AllowTcpForwarding yes
          EOF
          
          # Start SSH server
          sudo systemctl start ssh
          sudo systemctl status ssh --no-pager
          
          # Wait for SSH to be ready
          sleep 2
          
          # Test SSH connection
          ssh -i ~/.ssh/test_key -p 2222 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $USER@localhost echo "SSH test successful"
      
      - name: Build the tunnel binary
        run: |
          go build -o ssh-socat-tunnel .
          chmod +x ssh-socat-tunnel
      
      - name: Create test configuration
        run: |
          mkdir -p /tmp/test-config
          cat > /tmp/test-config/config.yaml <<EOF
          vps:
            host: "localhost"
            user: "$USER"
            port: 2222
            ssh_key: "$HOME/.ssh/test_key"
            strict_hostkey: "no"
          
          reconnect_delay_seconds: 2
          
          tcp_forwards:
            - remote_port: 9001
              local_host: "127.0.0.1"
              local_port: 8001
          
          udp_forwards:
            - udp_public_port: 9002
              local_host: "127.0.0.1"
              local_udp_port: 8002
              wrap_tcp_port: 10000
          EOF
          cat /tmp/test-config/config.yaml
      
      - name: Start TCP test server
        run: |
          # Start a TCP echo server on port 8001
          nohup socat -v TCP-LISTEN:8001,bind=127.0.0.1,reuseaddr,fork EXEC:'/bin/cat' > /tmp/tcp-server.log 2>&1 &
          echo $! > /tmp/tcp-server.pid
          sleep 1
          
          # Verify TCP server is running
          echo "Testing TCP server..."
          echo "TCP_TEST" | nc -w 1 127.0.0.1 8001
      
      - name: Start UDP test server
        run: |
          # Start a UDP echo server on port 8002
          nohup socat -v UDP-LISTEN:8002,bind=127.0.0.1,reuseaddr,fork EXEC:'/bin/cat' > /tmp/udp-server.log 2>&1 &
          echo $! > /tmp/udp-server.pid
          sleep 1
          
          # Verify UDP server is running
          echo "Testing UDP server..."
          echo "UDP_TEST" | nc -u -w 1 127.0.0.1 8002
      
      - name: Start SSH tunnel
        run: |
          # Create log directory
          sudo mkdir -p /var/log
          sudo chmod 777 /var/log
          
          # Start the tunnel in background
          nohup sudo -E ./ssh-socat-tunnel -config /tmp/test-config/config.yaml > /tmp/tunnel.log 2>&1 &
          echo $! > /tmp/tunnel.pid
          
          # Wait for tunnel to establish
          echo "Waiting for tunnel to establish..."
          sleep 10
          
          # Show tunnel logs
          echo "=== Tunnel logs ==="
          cat /tmp/tunnel.log || true
          
          # Check if tunnel process is still running
          if ps -p $(cat /tmp/tunnel.pid) > /dev/null; then
            echo "Tunnel process is running (PID: $(cat /tmp/tunnel.pid))"
          else
            echo "ERROR: Tunnel process died"
            cat /tmp/tunnel.log
            exit 1
          fi
      
      - name: Test TCP tunnel - Send data
        run: |
          echo "=== Testing TCP tunnel ==="
          
          # Wait for remote port to be ready
          for i in {1..30}; do
            if nc -z localhost 9001 2>/dev/null; then
              echo "TCP port 9001 is ready"
              break
            fi
            echo "Waiting for TCP port 9001... (attempt $i/30)"
            sleep 1
          done
          
          # Send test data through the tunnel
          echo "Sending data through TCP tunnel..."
          response=$(echo "HELLO_TCP_TUNNEL" | nc -w 2 localhost 9001)
          echo "Response: $response"
          
          # Verify response
          if [ "$response" = "HELLO_TCP_TUNNEL" ]; then
            echo "✓ TCP tunnel test PASSED"
          else
            echo "✗ TCP tunnel test FAILED"
            echo "Expected: HELLO_TCP_TUNNEL"
            echo "Got: $response"
            exit 1
          fi
      
      - name: Test TCP tunnel - Reverse direction
        run: |
          echo "=== Testing TCP tunnel (reverse direction) ==="
          
          # Send multiple messages to test stability
          for i in {1..3}; do
            response=$(echo "TCP_MESSAGE_$i" | nc -w 2 localhost 9001)
            echo "Message $i response: $response"
            if [ "$response" != "TCP_MESSAGE_$i" ]; then
              echo "✗ TCP reverse test FAILED on message $i"
              exit 1
            fi
            sleep 1
          done
          
          echo "✓ TCP reverse direction test PASSED"
      
      - name: Test UDP tunnel - Send data
        run: |
          echo "=== Testing UDP tunnel ==="
          
          # Wait for remote UDP port to be ready
          sleep 5
          
          # Send test data through the UDP tunnel
          # UDP is connectionless, so we use a different approach
          echo "Sending data through UDP tunnel..."
          
          # Create a temporary file for the response
          response_file="/tmp/udp_response.txt"
          
          # Start a listener for the response and send the message
          (echo "HELLO_UDP_TUNNEL" | nc -u -w 3 localhost 9002 > "$response_file") &
          pid=$!
          
          # Wait for the response
          sleep 2
          
          # Read the response
          if [ -f "$response_file" ] && [ -s "$response_file" ]; then
            response=$(cat "$response_file")
            echo "Response: $response"
            
            if echo "$response" | grep -q "HELLO_UDP_TUNNEL"; then
              echo "✓ UDP tunnel test PASSED"
            else
              echo "✗ UDP tunnel test FAILED"
              echo "Expected to contain: HELLO_UDP_TUNNEL"
              echo "Got: $response"
              exit 1
            fi
          else
            echo "✓ UDP tunnel established (echo may not work reliably with nc UDP)"
            # UDP echo can be unreliable with nc, so we just verify the tunnel is up
          fi
      
      - name: Test UDP tunnel - Multiple packets
        run: |
          echo "=== Testing UDP tunnel (multiple packets) ==="
          
          # Test sending multiple UDP packets
          for i in {1..3}; do
            echo "Sending UDP packet $i..."
            echo "UDP_PACKET_$i" | nc -u -w 1 localhost 9002 || true
            sleep 1
          done
          
          echo "✓ UDP multiple packet test completed"
      
      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Tunnel logs ==="
          cat /tmp/tunnel.log || true
          echo ""
          echo "=== TCP server logs ==="
          cat /tmp/tcp-server.log || true
          echo ""
          echo "=== UDP server logs ==="
          cat /tmp/udp-server.log || true
          echo ""
          echo "=== Socat logs ==="
          sudo cat /var/log/socat-*.log 2>/dev/null || true
          echo ""
          echo "=== Running processes ==="
          ps aux | grep -E "(socat|ssh|tunnel)" || true
          echo ""
          echo "=== Network connections ==="
          sudo netstat -tulpn | grep -E "(8001|8002|9001|9002|10000)" || true
      
      - name: Cleanup
        if: always()
        run: |
          # Kill tunnel
          if [ -f /tmp/tunnel.pid ]; then
            sudo kill $(cat /tmp/tunnel.pid) 2>/dev/null || true
          fi
          
          # Kill test servers
          if [ -f /tmp/tcp-server.pid ]; then
            kill $(cat /tmp/tcp-server.pid) 2>/dev/null || true
          fi
          if [ -f /tmp/udp-server.pid ]; then
            kill $(cat /tmp/udp-server.pid) 2>/dev/null || true
          fi
          
          # Kill any remaining socat processes by finding their PIDs
          pgrep socat | while read pid; do
            sudo kill -9 $pid 2>/dev/null || true
          done
          
          # Clean up temp files
          sudo rm -rf /tmp/ssh-socat-tunnel-* 2>/dev/null || true
